# Plugin Structure Specification

## ADDED Requirements

### Requirement: Plugin Directory Organization
The plugin SHALL provide a well-organized directory structure that separates backend logic, administration, and frontend code into distinct, maintainable layers.

#### Scenario: Directory structure for new plugin
- **WHEN** a developer initializes the plugin
- **THEN** the following directories are present with clear purposes:
  - `/admin` - Backend PHP logic, hooks, admin pages
  - `/admin/hooks` - Organized hook registrations
  - `/public` - Frontend PHP logic, shortcodes, templates
  - `/src/admin` - TypeScript/SCSS source for admin screens
  - `/src/public` - TypeScript/SCSS source for user-facing elements
  - `/src/public/components` - Reusable JavaScript components
  - `/src/shared` - Shared utilities (TypeScript/helpers)
  - `/assets` - Built JavaScript and CSS output (generated by Vite)

#### Scenario: Plugin bootstrap with proper headers
- **WHEN** the plugin is loaded by WordPress
- **THEN** the root plugin file (`cwp-wordpress-starter-plugin.php`) contains:
  - Proper WordPress plugin headers (Plugin Name, Description, Version, Author, Text Domain)
  - Text domain set to `cwp` for translations
  - Namespace `CWP\` for all PHP code to avoid conflicts
  - Autoloader or require statements for admin and public class files

### Requirement: Backend/Frontend Separation Pattern
The plugin architecture SHALL enforce a clear separation between backend (PHP/admin logic) and frontend (JavaScript/CSS for users) code with explicit integration points.

#### Scenario: Admin assets loading
- **WHEN** WordPress loads the admin area
- **THEN** the plugin enqueues scripts and styles from `/assets/admin.js` and `/assets/admin.css` only on relevant admin pages using proper `add_action()` hooks

#### Scenario: Frontend assets loading
- **WHEN** WordPress renders the public site
- **THEN** the plugin enqueues scripts and styles from `/assets/public.js` and `/assets/public.css` only when the component/shortcode/block is present

#### Scenario: No coupling between PHP and JavaScript
- **WHEN** developer modifies TypeScript in `/src/admin`
- **THEN** PHP files in `/admin` remain unaffected; integration happens only through built assets and data attributes

### Requirement: Plugin Main Entry Point
The plugin SHALL have a single, well-documented entry point that initializes all hooks, assets, and functionality.

#### Scenario: Plugin activation and initialization
- **WHEN** WordPress loads the plugin
- **THEN** a main `Plugin` class (in `admin/class-plugin.php`) is instantiated that:
  - Uses `CWP\StarterPlugin\Plugin` namespace
  - Registers text domain for translations in constructor
  - Sets up admin and public hooks automatically
  - Enqueues assets via hook methods

#### Scenario: Class-based hook registration
- **WHEN** the `Plugin` class is instantiated
- **THEN** its constructor registers hooks for asset enqueueing:
  - `add_action('admin_enqueue_scripts', [$this, 'enqueue_admin_assets'])`
  - `add_action('wp_enqueue_scripts', [$this, 'enqueue_public_assets'])`

#### Scenario: Namespace usage for all classes
- **WHEN** any PHP class is defined in the plugin
- **THEN** it uses the `CWP\StarterPlugin\` namespace to prevent conflicts with other plugins
